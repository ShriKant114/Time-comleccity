<h2>ğŸ“Š Time Complexity Chart (Low âœ High)</h2>

<table>
  <thead>
    <tr>
      <th>ğŸ“¶ Order</th>
      <th>â±ï¸ Big-O</th>
      <th>ğŸ§  Meaning</th>
      <th>ğŸ§ª Example</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>âœ… Constant</td>
      <td><code>O(1)</code></td>
      <td>Always same steps</td>
      <td>Accessing an array element: <code>arr[0]</code></td>
    </tr>
    <tr>
      <td>ğŸ” Logarithmic</td>
      <td><code>O(log n)</code></td>
      <td>Halves input every step</td>
      <td>Binary Search</td>
    </tr>
    <tr>
      <td>ğŸ§® Linear</td>
      <td><code>O(n)</code></td>
      <td>Each element processed once</td>
      <td>Loop through array</td>
    </tr>
    <tr>
      <td>ğŸ“Š Log-linear</td>
      <td><code>O(n log n)</code></td>
      <td>Good sorting algorithms</td>
      <td>Merge Sort, Quick Sort</td>
    </tr>
    <tr>
      <td>ğŸŒ€ Quadratic</td>
      <td><code>O(nÂ²)</code></td>
      <td>Nested loops</td>
      <td>Bubble Sort, Brute Force</td>
    </tr>
    <tr>
      <td>ğŸŒªï¸ Cubic</td>
      <td><code>O(nÂ³)</code></td>
      <td>Triple nested loops</td>
      <td>Naive matrix multiplication</td>
    </tr>
    <tr>
      <td>ğŸš« Exponential</td>
      <td><code>O(2â¿)</code></td>
      <td>Grows very fast</td>
      <td>Recursive Fibonacci</td>
    </tr>
    <tr>
      <td>âŒ Factorial</td>
      <td><code>O(n!)</code></td>
      <td>All permutations</td>
      <td>Travelling Salesman Problem</td>
    </tr>
  </tbody>
</table>

<p><strong>âš ï¸ Tip:</strong> Lower complexity = better performance. Avoid <code>O(nÂ²)</code> and worse on large data!</p>
